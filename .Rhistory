#output_data_cd=here("lou_files","cod_haddock","output_data")
iterative_input_data_cd="C:/Users/andrew.carr-harris/Desktop/flukeRDM_iterative_data"
input_data_cd="C:/Users/andrew.carr-harris/Desktop/MRIP_data_2025"
#Set number of original draws. We use 150 for the final run. Choose a lot fewer for test runs
n_simulations<-100
n_draws<-50 #Number of simulated trips per day
MRIP_comparison = read_dta(file.path(iterative_input_data_cd,"simulated_catch_totals.dta")) %>%
dplyr::rename(estimated_trips=tot_dtrip_sim,
sf_catch=tot_sf_cat_sim,
bsb_catch=tot_bsb_cat_sim,
scup_catch=tot_scup_cat_sim,
sf_keep=tot_sf_keep_sim,
bsb_keep=tot_bsb_keep_sim,
scup_keep=tot_scup_keep_sim,
sf_rel=tot_sf_rel_sim,
bsb_rel=tot_bsb_rel_sim,
scup_rel=tot_scup_rel_sim)
baseline_output0<-feather::read_feather(file.path(iterative_input_data_cd, "calibration_comparison.feather"))
states <- c("MA", "RI")
mode_draw <- c("sh", "pr", "fh")
draws <- 1:2
i<-1
s<-"MA"
md<-"pr"
# Create an empty list to collect results
calib_comparison <- list()
# Counter for appending to list
k <- 1
# Loop over all combinations
# for (s in states) {
#   for (md in mode_draw) {
#     for (i in draws) {
calib_comparison<-feather::read_feather(file.path(iterative_input_data_cd, "calibration_comparison.feather")) %>%
dplyr::filter(state==s & draw==i & mode==md)
for (p in 1:nrow(calib_comparison)) {
sp <- calib_comparison$species[p]
assign(paste0("rel_to_keep_", sp), calib_comparison$rel_to_keep[p])
assign(paste0("keep_to_rel_", sp), calib_comparison$keep_to_rel[p])
assign(paste0("harv_diff_", sp), abs(calib_comparison$diff[p]))
assign(paste0("harv_pct_diff_", sp), abs(calib_comparison$pct_diff[p]))
if (calib_comparison$rel_to_keep[p] == 1) {
assign(paste0("p_rel_to_keep_", sp), calib_comparison$p_rel_to_keep[p])
}
if (calib_comparison$keep_to_rel[p] == 1) {
assign(paste0("p_keep_to_rel_", sp), calib_comparison$p_keep_to_rel[p])
}
}
base_sf_achieved<-case_when((harv_diff_sf<500 | harv_pct_diff_sf<5)~1, TRUE~0)
base_bsb_achieved<-case_when((harv_diff_bsb<500 | harv_pct_diff_bsb<5)~1, TRUE~0)
base_scup_achieved<-case_when((harv_diff_scup<500 | harv_pct_diff_scup<5)~1, TRUE~0)
sf_achieved<-case_when(base_sf_achieved==1~1, TRUE~0)
bsb_achieved<-case_when(base_bsb_achieved==1~1, TRUE~0)
scup_achieved<-case_when(base_scup_achieved==1~1, TRUE~0)
if(base_sf_achieved==1  & base_bsb_achieved==1 & base_scup_achieved==1) break
if(base_sf_achieved!=1  | base_bsb_achieved!=1 | base_scup_achieved!=1) {
source(file.path(code_cd, "calibrate_rec_catch1.R"))
message("run ", i)
message("model_sf_harv: ", sf_keep_model)
message("mrip_sf_harv: ", sf_keep_MRIP)
message("diff_sf_harv: ", sf_keep_diff)
message("pct_diff_sf_harv: ", sf_keep_pct_diff)
message("rel_to_keep_sf: ", rel_to_keep_sf)
message("p_rel_to_keep_sf: ", p_rel_to_keep_sf)
message("p_keep_to_rel_sf: ", p_keep_to_rel_sf)
message("model_bsb_harv: ", bsb_keep_model)
message("mrip_bsb_harv: ", bsb_keep_MRIP)
message("diff_bsb_harv: ", bsb_keep_diff)
message("pct_diff_bsb_harv: ", bsb_keep_pct_diff)
message("rel_to_keep_bsb: ", rel_to_keep_bsb)
message("p_rel_to_keep_bsb: ", p_rel_to_keep_bsb)
message("p_keep_to_rel_bsb: ", p_keep_to_rel_bsb)
message("model_scup_harv: ", scup_keep_model)
message("mrip_scup_harv: ", scup_keep_MRIP)
message("diff_scup_harv: ", scup_keep_diff)
message("pct_diff_scup_harv: ", scup_keep_pct_diff)
message("rel_to_keep_scup: ", rel_to_keep_scup)
message("p_rel_to_keep_scup: ", p_rel_to_keep_scup)
message("p_keep_to_rel_scup: ", p_keep_to_rel_scup)
repeat{
#For draws where release_to_keep==1:
#If baseline sf harvest is less than MRIP, but in a new run sf harvest is greater than MRIP,
#reduce the baseline p_rel_to_keep value
if(rel_to_keep_sf==1 & sf_achieved!=1) {
if(sf_keep_diff>0){# & sf_keep_pct_diff>10){
p_rel_to_keep_sf<-p_rel_to_keep_sf -p_rel_to_keep_sf*.05
}
# if(sf_keep_diff>0 & sf_keep_pct_diff<= 10){
#   p_rel_to_keep_sf<-p_rel_to_keep_sf -.025
# }
#If baseline sf harvest is less than MRIP, and in the new run sf harvest is still less than MRIP,
#increase the baseline h_star_release_to_keep value
if(sf_keep_diff<0) {#& sf_keep_pct_diff< -10){
p_rel_to_keep_sf<-p_rel_to_keep_sf +p_rel_to_keep_sf*.06
}
# if(sf_keep_diff<0 & sf_keep_pct_diff>= -10){
#   p_rel_to_keep_sf<-p_rel_to_keep_sf +.03
# }
}
#same for bsb
#If baseline harvest is less than MRIP, but in  a new run sf harvest is greater than MRIP,
#reduce the baseline h_star_release_to_keep value
if(rel_to_keep_bsb==1 & bsb_achieved!=1) {
if(bsb_keep_diff>0){ #& bsb_keep_pct_diff> 10){
p_rel_to_keep_bsb<-p_rel_to_keep_bsb-p_rel_to_keep_bsb*.05
}
# if(bsb_keep_diff>0 & bsb_keep_pct_diff<= 10){
#   p_rel_to_keep_bsb<-p_rel_to_keep_bsb -.025
# }
#
#If baseline bsb harvest is less than MRIP, and in the new run bsb harvest is still less than MRIP,
#increase the baseline h_star_release_to_keep value
if(bsb_keep_diff<0){ #& bsb_keep_pct_diff< -10){
p_rel_to_keep_bsb<-p_rel_to_keep_bsb +p_rel_to_keep_bsb*.06
}
# if(bsb_keep_diff<0 & bsb_keep_pct_diff>= -10){
#   p_rel_to_keep_bsb<-p_rel_to_keep_bsb +.03
# }
}
#same for scup
#If baseline sf harvest is less than MRIP, but in  a new run sf harvest is greater than MRIP,
#reduce the baseline h_star_release_to_keep value
if(rel_to_keep_scup==1 & scup_achieved!=1) {
if(scup_keep_diff>0){# & scup_keep_pct_diff> 10){
p_rel_to_keep_scup<-p_rel_to_keep_scup -p_rel_to_keep_scup*.05
}
# if(scup_keep_diff>0 & scup_keep_pct_diff<= 10){
#   p_rel_to_keep_scup<-p_rel_to_keep_scup -.025
# }
#If baseline scup harvest is less than MRIP, and in the new run scup harvest is still less than MRIP,
#increase the baseline h_star_release_to_keep value
if(scup_keep_diff<0){# & scup_keep_pct_diff< -10){
p_rel_to_keep_scup<-p_rel_to_keep_scup +p_rel_to_keep_scup*.06
}
# if(scup_keep_diff<0 & scup_keep_pct_diff>= -10){
#   p_rel_to_keep_scup<-p_rel_to_keep_scup +.03
# }
}
#For draws where keep_to_release==1
#If in the baseline run, harvest is less than MRIP, but in a new run harvest is greater than MRIP,
#reduce the baseline h_star_release_to_keep value
if(keep_to_rel_sf==1 & sf_achieved!=1 & p_keep_to_rel_sf!=1) {
if(sf_keep_diff>0){# & comparison$perc_diff_cod_harv> 10){
p_keep_to_rel_sf<-p_keep_to_rel_sf +p_keep_to_rel_sf*.02
}
# if(comparison$diff_cod_harv>0 & comparison$perc_diff_cod_harv<= 10){
#   p_cod_kp_2_rl<-p_cod_kp_2_rl +.005
# }
#If in the baseline run, harvest is less than MRIP, and in the new run harvest is still less than MRIP,
#increase the baseline h_star_release_to_keep value
if(sf_keep_diff<0){
p_keep_to_rel_sf<-p_keep_to_rel_sf -p_keep_to_rel_sf*.01
}
}
#same for bsb
if(keep_to_rel_bsb==1 & bsb_achieved!=1 & p_keep_to_rel_bsb!=1) {
if(bsb_keep_diff>0){# & comparison$perc_diff_cod_harv> 10){
p_keep_to_rel_bsb<-p_keep_to_rel_bsb +p_keep_to_rel_bsb*.02
}
# if(comparison$diff_cod_harv>0 & comparison$perc_diff_cod_harv<= 10){
#   p_cod_kp_2_rl<-p_cod_kp_2_rl +.005
# }
#If in the baseline run, harvest is less than MRIP, and in the new run harvest is still less than MRIP,
#increase the baseline h_star_release_to_keep value
if(bsb_keep_diff<0){
p_keep_to_rel_bsb<-p_keep_to_rel_bsb -p_keep_to_rel_bsb*.01
}
}
#same for scup
if(keep_to_rel_scup==1 & scup_achieved!=1 & p_keep_to_rel_scup!=1) {
if(scup_keep_diff>0){# & comparison$perc_diff_cod_harv> 10){
p_keep_to_rel_scup<-p_keep_to_rel_scup +p_keep_to_rel_scup*.02
}
# if(comparison$diff_cod_harv>0 & comparison$perc_diff_cod_harv<= 10){
#   p_cod_kp_2_rl<-p_cod_kp_2_rl +.005
# }
#If in the baseline run, harvest is less than MRIP, and in the new run harvest is still less than MRIP,
#increase the baseline h_star_release_to_keep value
if(scup_keep_diff<0){
p_keep_to_rel_scup<-p_keep_to_rel_scup -p_keep_to_rel_scup*.01
}
}
if(p_keep_to_rel_sf==1) {
p_keep_to_rel_sf<-1
}
if(p_keep_to_rel_bsb==1 ) {
p_keep_to_rel_bsb<-1
}
if(p_keep_to_rel_scup==1 ) {
p_keep_to_rel_scup<-1
}
source(file.path(code_cd, "calibrate_rec_catch1.R"))
message("run ", i)
message("model_sf_harv: ", sf_keep_model)
message("mrip_sf_harv: ", sf_keep_MRIP)
message("diff_sf_harv: ", sf_keep_diff)
message("pct_diff_sf_harv: ", sf_keep_pct_diff)
message("rel_to_keep_sf: ", rel_to_keep_sf)
message("p_rel_to_keep_sf: ", p_rel_to_keep_sf)
message("p_keep_to_rel_sf: ", p_keep_to_rel_sf)
message("model_bsb_harv: ", bsb_keep_model)
message("mrip_bsb_harv: ", bsb_keep_MRIP)
message("diff_bsb_harv: ", bsb_keep_diff)
message("pct_diff_bsb_harv: ", bsb_keep_pct_diff)
message("rel_to_keep_bsb: ", rel_to_keep_bsb)
message("p_rel_to_keep_bsb: ", p_rel_to_keep_bsb)
message("p_keep_to_rel_bsb: ", p_keep_to_rel_bsb)
message("model_scup_harv: ", scup_keep_model)
message("mrip_scup_harv: ", scup_keep_MRIP)
message("diff_scup_harv: ", scup_keep_diff)
message("pct_diff_scup_harv: ", scup_keep_pct_diff)
message("rel_to_keep_scup: ", rel_to_keep_scup)
message("p_rel_to_keep_scup: ", p_rel_to_keep_scup)
message("p_keep_to_rel_scup: ", p_keep_to_rel_scup)
sf_achieved<-case_when((harv_diff_sf<500 | harv_pct_diff_sf<5)~1, TRUE~0)
bsb_achieved<-case_when((harv_diff_bsb<500 | harv_pct_diff_bsb<5)~1, TRUE~0)
scup_achieved<-case_when((harv_diff_scup<500 | harv_pct_diff_scup<5)~1, TRUE~0)
if (sf_achieved==1 & bsb_achieved==1 & scup_achieved==1) break
}
}
input_data_cd=here("Data")
test_data_cd=here("Data", "Test_data")
code_cd=here("Code", "sim")
#output_data_cd=here("lou_files","cod_haddock","output_data")
iterative_input_data_cd="C:/Users/andrew.carr-harris/Desktop/flukeRDM_iterative_data"
input_data_cd="C:/Users/andrew.carr-harris/Desktop/MRIP_data_2025"
#Set number of original draws. We use 150 for the final run. Choose a lot fewer for test runs
n_simulations<-100
n_draws<-50 #Number of simulated trips per day
MRIP_comparison = read_dta(file.path(iterative_input_data_cd,"simulated_catch_totals.dta")) %>%
dplyr::rename(estimated_trips=tot_dtrip_sim,
sf_catch=tot_sf_cat_sim,
bsb_catch=tot_bsb_cat_sim,
scup_catch=tot_scup_cat_sim,
sf_keep=tot_sf_keep_sim,
bsb_keep=tot_bsb_keep_sim,
scup_keep=tot_scup_keep_sim,
sf_rel=tot_sf_rel_sim,
bsb_rel=tot_bsb_rel_sim,
scup_rel=tot_scup_rel_sim)
baseline_output0<-feather::read_feather(file.path(iterative_input_data_cd, "calibration_comparison.feather"))
states <- c("MA", "RI")
mode_draw <- c("sh", "pr", "fh")
draws <- 1:2
i<-1
s<-"MA"
md<-"pr"
# Create an empty list to collect results
calib_comparison <- list()
# Counter for appending to list
k <- 1
# Loop over all combinations
# for (s in states) {
#   for (md in mode_draw) {
#     for (i in draws) {
calib_comparison<-feather::read_feather(file.path(iterative_input_data_cd, "calibration_comparison.feather")) %>%
dplyr::filter(state==s & draw==i & mode==md)
for (p in 1:nrow(calib_comparison)) {
sp <- calib_comparison$species[p]
assign(paste0("rel_to_keep_", sp), calib_comparison$rel_to_keep[p])
assign(paste0("keep_to_rel_", sp), calib_comparison$keep_to_rel[p])
if (calib_comparison$rel_to_keep[p] == 1) {
assign(paste0("p_rel_to_keep_", sp), calib_comparison$p_rel_to_keep[p])
assign(paste0("p_keep_to_rel_", sp), 0)
}
if (calib_comparison$keep_to_rel[p] == 1) {
assign(paste0("p_keep_to_rel_", sp), calib_comparison$p_keep_to_rel[p])
assign(paste0("p_rel_to_keep_", sp), 0)
}
}
base_sf_achieved<-case_when((harv_diff_sf<500 | harv_pct_diff_sf<5)~1, TRUE~0)
until simulated harvest in numbers of fish is within 5% or 500 fish of the MRIP estimate.
input_data_cd=here("Data")
test_data_cd=here("Data", "Test_data")
code_cd=here("Code", "sim")
#output_data_cd=here("lou_files","cod_haddock","output_data")
iterative_input_data_cd="C:/Users/andrew.carr-harris/Desktop/flukeRDM_iterative_data"
input_data_cd="C:/Users/andrew.carr-harris/Desktop/MRIP_data_2025"
#Set number of original draws. We use 150 for the final run. Choose a lot fewer for test runs
n_simulations<-100
n_draws<-50 #Number of simulated trips per day
MRIP_comparison = read_dta(file.path(iterative_input_data_cd,"simulated_catch_totals.dta")) %>%
dplyr::rename(estimated_trips=tot_dtrip_sim,
sf_catch=tot_sf_cat_sim,
bsb_catch=tot_bsb_cat_sim,
scup_catch=tot_scup_cat_sim,
sf_keep=tot_sf_keep_sim,
bsb_keep=tot_bsb_keep_sim,
scup_keep=tot_scup_keep_sim,
sf_rel=tot_sf_rel_sim,
bsb_rel=tot_bsb_rel_sim,
scup_rel=tot_scup_rel_sim)
baseline_output0<-feather::read_feather(file.path(iterative_input_data_cd, "calibration_comparison.feather"))
states <- c("MA", "RI")
mode_draw <- c("sh", "pr", "fh")
draws <- 1:2
i<-1
s<-"MA"
md<-"pr"
# Create an empty list to collect results
calib_comparison <- list()
# Counter for appending to list
k <- 1
# Loop over all combinations
# for (s in states) {
#   for (md in mode_draw) {
#     for (i in draws) {
calib_comparison<-feather::read_feather(file.path(iterative_input_data_cd, "calibration_comparison.feather")) %>%
dplyr::filter(state==s & draw==i & mode==md)
for (p in 1:nrow(calib_comparison)) {
sp <- calib_comparison$species[p]
assign(paste0("rel_to_keep_", sp), calib_comparison$rel_to_keep[p])
assign(paste0("keep_to_rel_", sp), calib_comparison$keep_to_rel[p])
if (calib_comparison$rel_to_keep[p] == 1) {
assign(paste0("p_rel_to_keep_", sp), calib_comparison$p_rel_to_keep[p])
assign(paste0("p_keep_to_rel_", sp), 0)
}
if (calib_comparison$keep_to_rel[p] == 1) {
assign(paste0("p_keep_to_rel_", sp), calib_comparison$p_keep_to_rel[p])
assign(paste0("p_rel_to_keep_", sp), 0)
}
}
MRIP_comparison_draw <- MRIP_comparison %>%
dplyr::filter(draw==i & state==s)%>%
dplyr::filter(mode==md)
mode_val <- MRIP_comparison_draw$mode
# Loop over summary columns
for (var in names(MRIP_comparison_draw)[names(MRIP_comparison_draw) != "mode"]) {
value <- MRIP_comparison_draw[[var]]
obj_name <- paste0(var, "_", mode_val, "_MRIP")
assign(obj_name, value)
}
species <- c("sf", "bsb", "scup")
dispositions <- c("keep", "rel", "catch")
compare <- data.frame()
for (sp in species) {
for (disp in dispositions) {
# Construct variable names
base_name <- paste(sp, disp, md, sep = "_")
mrip_var <- paste0(base_name, "_MRIP")
model_var <- paste0(base_name, "_model")
# Check if both variables exist
if (exists(mrip_var) && exists(model_var)) {
# Retrieve values
mrip_val <- get(mrip_var)
model_val <- get(model_var)
# Calculate differences
diff_val <- model_val - mrip_val
pct_diff_val <- if (mrip_val != 0)  (diff_val / mrip_val) * 100 else NA
abs_diff_val <- abs(model_val - mrip_val)
abs_pct_diff_val <- if (mrip_val != 0)  abs((diff_val / mrip_val) * 100) else NA
# Create output variable names
assign(paste0(base_name, "_diff"), diff_val)
assign(paste0(base_name, "_pctdiff"), pct_diff_val)
assign(paste0(base_name, "_abs_diff"), abs_diff_val)
assign(paste0(base_name, "_abs_pctdiff"), abs_pct_diff_val)
compare <- rbind(compare, data.frame(
species = sp,
disposition = disp,
mode = md,
MRIP = mrip_val,
model = model_val,
diff = diff_val,
pct_diff = pct_diff_val,
abs_diff_val= abs_diff_val,
abs_pct_diff_val= abs_pct_diff_val
))
}
else {
warning(paste("Missing variable:", mrip_var, "or", model_var))
}
}
}
#This file pulls in the data from step 1, i.e., the differences between model simulated harvest
#and MRIP estimates of harvest, and re-runs the calibration model but this time adjusts per-trip
#outcomes until simulated harvest in numbers of fish is within 5% or 500 fish of the MRIP estimate.
input_data_cd=here("Data")
test_data_cd=here("Data", "Test_data")
code_cd=here("Code", "sim")
#output_data_cd=here("lou_files","cod_haddock","output_data")
iterative_input_data_cd="C:/Users/andrew.carr-harris/Desktop/flukeRDM_iterative_data"
input_data_cd="C:/Users/andrew.carr-harris/Desktop/MRIP_data_2025"
#Set number of original draws. We use 150 for the final run. Choose a lot fewer for test runs
n_simulations<-100
n_draws<-50 #Number of simulated trips per day
MRIP_comparison = read_dta(file.path(iterative_input_data_cd,"simulated_catch_totals.dta")) %>%
dplyr::rename(estimated_trips=tot_dtrip_sim,
sf_catch=tot_sf_cat_sim,
bsb_catch=tot_bsb_cat_sim,
scup_catch=tot_scup_cat_sim,
sf_keep=tot_sf_keep_sim,
bsb_keep=tot_bsb_keep_sim,
scup_keep=tot_scup_keep_sim,
sf_rel=tot_sf_rel_sim,
bsb_rel=tot_bsb_rel_sim,
scup_rel=tot_scup_rel_sim)
baseline_output0<-feather::read_feather(file.path(iterative_input_data_cd, "calibration_comparison.feather"))
states <- c("MA", "RI")
mode_draw <- c("sh", "pr", "fh")
draws <- 1:2
i<-1
s<-"MA"
md<-"pr"
# Create an empty list to collect results
calib_comparison <- list()
# Counter for appending to list
k <- 1
# Loop over all combinations
# for (s in states) {
#   for (md in mode_draw) {
#     for (i in draws) {
calib_comparison<-feather::read_feather(file.path(iterative_input_data_cd, "calibration_comparison.feather")) %>%
dplyr::filter(state==s & draw==i & mode==md)
for (p in 1:nrow(calib_comparison)) {
sp <- calib_comparison$species[p]
assign(paste0("rel_to_keep_", sp), calib_comparison$rel_to_keep[p])
assign(paste0("keep_to_rel_", sp), calib_comparison$keep_to_rel[p])
if (calib_comparison$rel_to_keep[p] == 1) {
assign(paste0("p_rel_to_keep_", sp), calib_comparison$p_rel_to_keep[p])
assign(paste0("p_keep_to_rel_", sp), 0)
}
if (calib_comparison$keep_to_rel[p] == 1) {
assign(paste0("p_keep_to_rel_", sp), calib_comparison$p_keep_to_rel[p])
assign(paste0("p_rel_to_keep_", sp), 0)
}
}
}
MRIP_comparison_draw <- MRIP_comparison %>%
dplyr::filter(draw==i & state==s)%>%
dplyr::filter(mode==md)
mode_val <- MRIP_comparison_draw$mode
# Loop over summary columns
for (var in names(MRIP_comparison_draw)[names(MRIP_comparison_draw) != "mode"]) {
value <- MRIP_comparison_draw[[var]]
obj_name <- paste0(var, "_", mode_val, "_MRIP")
assign(obj_name, value)
}
species <- c("sf", "bsb", "scup")
dispositions <- c("keep", "rel", "catch")
compare <- data.frame()
View(MRIP_comparison_draw)
calib_comparison<-feather::read_feather(file.path(iterative_input_data_cd, "calibration_comparison.feather")) %>%
dplyr::filter(state==s & draw==i & mode==md)
for (p in 1:nrow(calib_comparison)) {
sp <- calib_comparison$species[p]
assign(paste0("rel_to_keep_", sp), calib_comparison$rel_to_keep[p])
assign(paste0("keep_to_rel_", sp), calib_comparison$keep_to_rel[p])
if (calib_comparison$rel_to_keep[p] == 1) {
assign(paste0("p_rel_to_keep_", sp), calib_comparison$p_rel_to_keep[p])
assign(paste0("p_keep_to_rel_", sp), 0)
}
if (calib_comparison$keep_to_rel[p] == 1) {
assign(paste0("p_keep_to_rel_", sp), calib_comparison$p_keep_to_rel[p])
assign(paste0("p_rel_to_keep_", sp), 0)
}
}
MRIP_comparison_draw <- MRIP_comparison %>%
dplyr::filter(draw==i & state==s) %>%
dplyr::filter(mode==md)
mode_val <- MRIP_comparison_draw$mode
View(MRIP_comparison_draw)
for (var in names(MRIP_comparison_draw)[names(MRIP_comparison_draw) != "mode"]) {
value <- MRIP_comparison_draw[[var]]
obj_name <- paste0(var, "_", mode_val, "_MRIP")
assign(obj_name, value)
}
species <- c("sf", "bsb", "scup")
dispositions <- c("keep", "rel", "catch")
compare <- data.frame()
for (sp in species) {
for (disp in dispositions) {
# Construct variable names
base_name <- paste(sp, disp, md, sep = "_")
mrip_var <- paste0(base_name, "_MRIP")
model_var <- paste0(base_name, "_model")
# Check if both variables exist
if (exists(mrip_var) && exists(model_var)) {
# Retrieve values
mrip_val <- get(mrip_var)
model_val <- get(model_var)
# Calculate differences
diff_val <- model_val - mrip_val
pct_diff_val <- if (mrip_val != 0)  (diff_val / mrip_val) * 100 else NA
abs_diff_val <- abs(model_val - mrip_val)
abs_pct_diff_val <- if (mrip_val != 0)  abs((diff_val / mrip_val) * 100) else NA
# Create output variable names
assign(paste0(base_name, "_diff"), diff_val)
assign(paste0(base_name, "_pctdiff"), pct_diff_val)
assign(paste0(base_name, "_abs_diff"), abs_diff_val)
assign(paste0(base_name, "_abs_pctdiff"), abs_pct_diff_val)
compare <- rbind(compare, data.frame(
species = sp,
disposition = disp,
mode = md,
MRIP = mrip_val,
model = model_val,
diff = diff_val,
pct_diff = pct_diff_val,
abs_diff_val= abs_diff_val,
abs_pct_diff_val= abs_pct_diff_val
))
}
else {
warning(paste("Missing variable:", mrip_var, "or", model_var))
}
}
}
# Construct variable names
base_name <- paste(sp, disp, md, sep = "_")
mrip_var <- paste0(base_name, "_MRIP")
model_var <- paste0(base_name, "_model")
mrip_val <- get(mrip_var)
model_val <- get(model_var)
