input_data_cd=here("Data")
test_data_cd=here("Data", "Test_data")
code_cd=here("Code", "sim")
#output_data_cd=here("lou_files","cod_haddock","output_data")
iterative_input_data_cd="C:/Users/andrew.carr-harris/Desktop/flukeRDM_iterative_data"
input_data_cd="C:/Users/andrew.carr-harris/Desktop/MRIP_data_2025"
n_simulations<-100
n_draws<-50 #Number of simulated trips per day
input_data_cd=here("Data")
test_data_cd=here("Data", "Test_data")
code_cd=here("Code", "sim")
#output_data_cd=here("lou_files","cod_haddock","output_data")
iterative_input_data_cd="C:/Users/andrew.carr-harris/Desktop/flukeRDM_iterative_data"
input_data_cd="C:/Users/andrew.carr-harris/Desktop/MRIP_data_2025"
#Set number of original draws. We use 150 for the final run. Choose a lot fewer for test runs
n_simulations<-5
n_draws<-50 #Number of simulated trips per day
MRIP_comparison = read_dta(file.path(iterative_input_data_cd,"simulated_catch_totals.dta")) %>%
dplyr::rename(estimated_trips=tot_dtrip_sim,
sf_catch=tot_sf_cat_sim,
bsb_catch=tot_bsb_cat_sim,
scup_catch=tot_scup_cat_sim,
sf_keep=tot_sf_keep_sim,
bsb_keep=tot_bsb_keep_sim,
scup_keep=tot_scup_keep_sim,
sf_rel=tot_sf_rel_sim,
bsb_rel=tot_bsb_rel_sim,
scup_rel=tot_scup_rel_sim)
baseline_output0<-feather::read_feather(file.path(iterative_input_data_cd, "calibration_comparison.feather"))
states <- c("MA", "RI", "CT", "NY", "NJ", "DE", "MD", "VA", "NC")
mode_draw <- c("sh", "pr", "fh")
draws <- 1:3
#
#   i<-1
#   s<-"CT"
#   md<-"fh"
#
# Create an empty list to collect results
calibrated <- list()
# Counter for appending to list
k <- 1
# Loop over all combinations
for (s in states){
for (md in mode_draw){
for (i in draws) {
calib_comparison<-feather::read_feather(file.path(iterative_input_data_cd, "calibration_comparison.feather")) %>%
dplyr::filter(state==s & draw==i & mode==md)
for (p in 1:nrow(calib_comparison)) {
sp <- calib_comparison$species[p]
assign(paste0("rel_to_keep_", sp), calib_comparison$rel_to_keep[p])
assign(paste0("keep_to_rel_", sp), calib_comparison$keep_to_rel[p])
assign(paste0("harv_diff_", sp), calib_comparison$diff[p])
assign(paste0("harv_pct_diff_", sp), calib_comparison$pct_diff[p])
if (calib_comparison$rel_to_keep[p] == 1) {
assign(paste0("p_rel_to_keep_", sp), calib_comparison$p_rel_to_keep[p])
assign(paste0("p_keep_to_rel_", sp), 0)
}
if (calib_comparison$keep_to_rel[p] == 1) {
assign(paste0("p_keep_to_rel_", sp), calib_comparison$p_keep_to_rel[p])
assign(paste0("p_rel_to_keep_", sp), 0)
}
}
all_keep_to_rel_sf<-case_when(p_keep_to_rel_sf==1~1, TRUE~0)
all_keep_to_rel_bsb<-case_when(p_keep_to_rel_bsb==1~1, TRUE~0)
all_keep_to_rel_scup<-case_when(p_keep_to_rel_scup==1~1, TRUE~0)
source(file.path(code_cd, "calibrate_rec_catch1.R"))
for (p in 1:nrow(calib_comparison1)) {
sp <- calib_comparison1$species[p]
assign(paste0("MRIP_keep_", sp), calib_comparison1$MRIP_keep[p])
assign(paste0("model_keep_", sp), calib_comparison1$model_keep[p])
assign(paste0("harv_diff_", sp), calib_comparison1$diff_keep[p])
assign(paste0("harv_pct_diff_", sp), calib_comparison1$pct_diff_keep[p])
# assign(paste0("rel_to_keep_", sp), calib_comparison1$rel_to_keep_new[p])
# assign(paste0("keep_to_rel_", sp), calib_comparison1$keep_to_rel_new[p])
}
message("run ", i, " state ", s, " mode ", md)
message("model_sf_harv: ", model_keep_sf)
message("mrip_sf_harv: ", MRIP_keep_sf)
message("diff_sf_harv: ", harv_diff_sf)
message("pct_diff_sf_harv: ", harv_pct_diff_sf)
message("rel_to_keep_sf: ", rel_to_keep_sf)
message("p_rel_to_keep_sf: ", p_rel_to_keep_sf)
message("p_keep_to_rel_sf: ", p_keep_to_rel_sf)
message("model_bsb_harv: ", model_keep_bsb)
message("mrip_bsb_harv: ", MRIP_keep_bsb)
message("diff_bsb_harv: ", harv_diff_bsb)
message("pct_diff_bsb_harv: ", harv_pct_diff_bsb)
message("rel_to_keep_bsb: ", rel_to_keep_bsb)
message("p_rel_to_keep_bsb: ", p_rel_to_keep_bsb)
message("p_keep_to_rel_bsb: ", p_keep_to_rel_bsb)
message("model_scup_harv: ", model_keep_scup)
message("mrip_scup_harv: ", MRIP_keep_scup)
message("diff_scup_harv: ", harv_diff_scup)
message("pct_diff_scup_harv: ", harv_pct_diff_scup)
message("rel_to_keep_scup: ", rel_to_keep_scup)
message("p_rel_to_keep_scup: ", p_rel_to_keep_scup)
message("p_keep_to_rel_scup: ", p_keep_to_rel_scup)
sf_achieved<-case_when((abs(harv_diff_sf)<500 | (abs(harv_pct_diff_sf)<5 & !is.na(harv_pct_diff_sf))) ~1, TRUE~0)
bsb_achieved<-case_when((abs(harv_diff_bsb)<500 | (abs(harv_pct_diff_bsb)<5 & !is.na(harv_pct_diff_bsb))) ~1, TRUE~0)
scup_achieved<-case_when((abs(harv_diff_scup)<500 | (abs(harv_pct_diff_scup)<5 & !is.na(harv_pct_diff_scup))) ~1, TRUE~0)
# Here I add a non-convergence indicator and artificially deem the run as achieved
sf_convergence<-1
bsb_convergence<-1
scup_convergence<-1
while(sf_achieved+bsb_achieved+scup_achieved<3){
#For draws where release_to_keep==1:
#If baseline sf harvest is less than MRIP, but in a new run sf harvest is greater than MRIP,
#reduce the baseline p_rel_to_keep value
if(sf_achieved!=1){
if(rel_to_keep_sf==1){
if(harv_diff_sf>0){
p_rel_to_keep_sf<-p_rel_to_keep_sf - p_rel_to_keep_sf*.15
}
#If baseline sf harvest is less than MRIP, and in the new run sf harvest is still less than MRIP,
#increase the baseline p_rel_to_keep value
if(harv_diff_sf<0) {
p_rel_to_keep_sf<-p_rel_to_keep_sf + p_rel_to_keep_sf*.16
}
}
#For draws where keep_to_release==1
#If in the baseline run, harvest is less than MRIP, but in a new run harvest is greater than MRIP,
#reduce the baseline p_keep_to_rel value
if(keep_to_rel_sf==1 & all_keep_to_rel_sf!=1) {
if(harv_diff_sf>0){
p_keep_to_rel_sf<-p_keep_to_rel_sf + p_keep_to_rel_sf*.16
}
#If in the baseline run, harvest is less than MRIP, and in the new run harvest is still less than MRIP,
#increase the baseline p_keep_to_rel value
if(harv_diff_sf<0){
p_keep_to_rel_sf<-p_keep_to_rel_sf - p_keep_to_rel_sf*.15
}
}
}
#BSB
#For draws where release_to_keep==1:
#If baseline sf harvest is less than MRIP, but in a new run sf harvest is greater than MRIP,
#reduce the baseline p_rel_to_keep value
if(bsb_achieved!=1){
if(rel_to_keep_bsb==1){
if(harv_diff_bsb>0){
p_rel_to_keep_bsb<-p_rel_to_keep_bsb - p_rel_to_keep_bsb*.15
}
#If baseline bsb harvest is less than MRIP, and in the new run bsb harvest is still less than MRIP,
#increase the baseline p_rel_to_keep value
if(harv_diff_bsb<0) {
p_rel_to_keep_bsb<-p_rel_to_keep_bsb + p_rel_to_keep_bsb*.16
}
}
#For draws where keep_to_release==1
#If in the baseline run, harvest is less than MRIP, but in a new run harvest is greater than MRIP,
#reduce the baseline p_keep_to_rel value
if(keep_to_rel_bsb==1 & all_keep_to_rel_bsb!=1) {
if(harv_diff_bsb>0){
p_keep_to_rel_bsb<-p_keep_to_rel_bsb + p_keep_to_rel_bsb*.16
}
#If in the baseline run, harvest is less than MRIP, and in the new run harvest is still less than MRIP,
#increase the baseline p_keep_to_rel value
if(harv_diff_bsb<0){
p_keep_to_rel_bsb<-p_keep_to_rel_bsb - p_keep_to_rel_bsb*.15
}
}
}
#Scup
#For draws where release_to_keep==1:
#If baseline sf harvest is less than MRIP, but in a new run sf harvest is greater than MRIP,
#reduce the baseline p_rel_to_keep value
if(scup_achieved!=1){
if(rel_to_keep_scup==1){
if(harv_diff_scup>0){
p_rel_to_keep_scup<-p_rel_to_keep_scup - p_rel_to_keep_scup*.15
}
#If baseline scup harvest is less than MRIP, and in the new run scup harvest is still less than MRIP,
#increase the baseline p_rel_to_keep value
if(harv_diff_scup<0) {
p_rel_to_keep_scup<-p_rel_to_keep_scup + p_rel_to_keep_scup*.16
}
}
#For draws where keep_to_release==1
#If in the baseline run, harvest is less than MRIP, but in a new run harvest is greater than MRIP,
#reduce the baseline p_keep_to_rel value
if(keep_to_rel_scup==1 & all_keep_to_rel_scup!=1) {
if(harv_diff_scup>0){
p_keep_to_rel_scup<-p_keep_to_rel_scup + p_keep_to_rel_scup*.16
}
#If in the baseline run, harvest is less than MRIP, and in the new run harvest is still less than MRIP,
#increase the baseline p_keep_to_rel value
if(harv_diff_scup<0){
p_keep_to_rel_scup<-p_keep_to_rel_scup - p_keep_to_rel_scup*.15
}
}
}
if(all_keep_to_rel_sf==1 & sf_achieved!=1) {
p_keep_to_rel_sf<-1
}
if(all_keep_to_rel_bsb==1 & bsb_achieved!=1) {
p_keep_to_rel_bsb<-1
}
if(all_keep_to_rel_scup==1 & scup_achieved!=1) {
p_keep_to_rel_scup<-1
}
source(file.path(code_cd, "calibrate_rec_catch1.R"))
for (p in 1:nrow(calib_comparison1)) {
sp <- calib_comparison1$species[p]
assign(paste0("MRIP_keep_", sp), calib_comparison1$MRIP_keep[p])
assign(paste0("model_keep_", sp), calib_comparison1$model_keep[p])
assign(paste0("harv_diff_", sp), calib_comparison1$diff_keep[p])
assign(paste0("harv_pct_diff_", sp), calib_comparison1$pct_diff_keep[p])
# assign(paste0("rel_to_keep_", sp), calib_comparison1$rel_to_keep_new[p])
# assign(paste0("keep_to_rel_", sp), calib_comparison1$keep_to_rel_new[p])
}
message("run ", i, " state ", s, " mode ", md)
message("model_sf_harv: ", model_keep_sf)
message("mrip_sf_harv: ", MRIP_keep_sf)
message("diff_sf_harv: ", harv_diff_sf)
message("pct_diff_sf_harv: ", harv_pct_diff_sf)
message("rel_to_keep_sf: ", rel_to_keep_sf)
message("p_rel_to_keep_sf: ", p_rel_to_keep_sf)
message("p_keep_to_rel_sf: ", p_keep_to_rel_sf)
message("model_bsb_harv: ", model_keep_bsb)
message("mrip_bsb_harv: ", MRIP_keep_bsb)
message("diff_bsb_harv: ", harv_diff_bsb)
message("pct_diff_bsb_harv: ", harv_pct_diff_bsb)
message("rel_to_keep_bsb: ", rel_to_keep_bsb)
message("p_rel_to_keep_bsb: ", p_rel_to_keep_bsb)
message("p_keep_to_rel_bsb: ", p_keep_to_rel_bsb)
message("model_scup_harv: ", model_keep_scup)
message("mrip_scup_harv: ", MRIP_keep_scup)
message("diff_scup_harv: ", harv_diff_scup)
message("pct_diff_scup_harv: ", harv_pct_diff_scup)
message("rel_to_keep_scup: ", rel_to_keep_scup)
message("p_rel_to_keep_scup: ", p_rel_to_keep_scup)
message("p_keep_to_rel_scup: ", p_keep_to_rel_scup)
sf_achieved<-case_when((abs(harv_diff_sf)<500 | (abs(harv_pct_diff_sf)<5 & !is.na(harv_pct_diff_sf))) ~1, TRUE~0)
bsb_achieved<-case_when((abs(harv_diff_bsb)<500 | (abs(harv_pct_diff_bsb)<5 & !is.na(harv_pct_diff_bsb))) ~1, TRUE~0)
scup_achieved<-case_when((abs(harv_diff_scup)<500 | (abs(harv_pct_diff_scup)<5 & !is.na(harv_pct_diff_scup))) ~1, TRUE~0)
# In some cases, there are not enough fish within 3-inches of the minimum size to re-allocate
# from kept to release. In this case, p_rel_to_keep_SP will continue to grow unbounded.
if(rel_to_keep_sf==1 & p_rel_to_keep_sf>1){
sf_convergence<-0
sf_achieved<-1
}
if(rel_to_keep_bsb==1 & p_rel_to_keep_bsb>1){
bsb_convergence<-0
bsb_achieved<-1
}
if(rel_to_keep_scup==1 & p_rel_to_keep_scup>1){
scup_convergence<-0
scup_achieved<-1
}
}
k <- k + 1
calibrated[[k]] <- calib_comparison1 %>%
dplyr::mutate(keep_to_rel_sf=keep_to_rel_sf,
rel_to_keep_sf=  rel_to_keep_sf,
p_rel_to_keep_sf=p_rel_to_keep_sf,
p_keep_to_rel_sf= p_keep_to_rel_sf,
sf_convergence=sf_convergence,
keep_to_rel_bsb=keep_to_rel_bsb,
rel_to_keep_bsb=  rel_to_keep_bsb,
p_rel_to_keep_bsb= p_rel_to_keep_bsb,
p_keep_to_rel_bsb= p_keep_to_rel_bsb,
bsb_convergence=bsb_convergence,
keep_to_rel_scup=keep_to_rel_scup,
rel_to_keep_scup =rel_to_keep_scup,
p_rel_to_keep_scup=p_rel_to_keep_scup,
p_keep_to_rel_scup=p_keep_to_rel_scup,
scup_convergence=scup_convergence,
n_sub_scup_kept=n_sub_scup_kept,
prop_sub_scup_kept=prop_sub_scup_kept,
n_legal_scup_rel=n_legal_scup_rel,
prop_legal_scup_rel=prop_legal_scup_rel,
n_sub_sf_kept=n_sub_sf_kept,
n_legal_sf_rel=n_legal_sf_rel,
prop_sub_sf_kept=prop_sub_sf_kept,
prop_legal_sf_rel=prop_legal_sf_rel,
n_sub_bsb_kept=n_sub_bsb_kept,
n_legal_bsb_rel=n_legal_bsb_rel,
prop_sub_bsb_kept=prop_sub_bsb_kept,
prop_legal_bsb_rel=prop_legal_bsb_rel)
}
}
}
calibrated_combined <- do.call(rbind, calibrated)
saveRDS(calibrated_combined, file = file.path(iterative_input_data_cd, "calibrated_model_stats.rds"))
#check<-readRDS(file = file.path(iterative_input_data_cd, "calibrated_model_stats.rds"))
warnings()
View(calibrated_combined)
check<-calibrated_combined %>%
dplyr::filter(sf_convergence!=1 | bsb_convergence!=-1 | scup_convergence!=1)
View(check)
dplyr::filter(sf_convergence!=1 | bsb_convergence!=1 | scup_convergence!=1)
check<-calibrated_combined %>%
dplyr::filter(sf_convergence!=1 | bsb_convergence!=1 | scup_convergence!=1)
View(check)
check<-calibrated_combined %>%
dplyr::filter(sf_convergence==0 | bsb_convergence==0  | scup_convergence==0 )
View(check)
check<-calibrated_combined %>%
dplyr::filter(diff_keep>500 & abs(pct_diff_keep)>5 )
check<-calibrated_combined %>%
dplyr::filter(diff_keep>500 & abs(pct_diff_keep)>5 & !is.na(pct_diff_keep) )
check<-calibrated_combined %>%
dplyr::filter(abs(diff_keep)>500 & abs(pct_diff_keep)>5 & !is.na(pct_diff_keep) )
243/3
ls(calibrated_combined)
calibrated_combined <- do.call(rbind, calibrated) %>%
dplyr::select(-rel_to_keep_new, -keep_to_rel_new, -p_keep_to_rel_new, -p_rel_to_keep_new)
saveRDS(calibrated_combined, file = file.path(iterative_input_data_cd, "calibrated_model_stats.rds"))
calib_comparison<-feather::read_feather(file.path(iterative_input_data_cd, "calibration_comparison.feather"))
View(calib_comparison)
statez <- c("MA", "RI", "CT", "NY", "NJ", "DE", "MD", "VA", "NC")
for(s in statez) {
dtrip0<-read.csv(file.path(input_data_cd, paste0("directed_trips_calibration_", s,".csv")))
write_feather(dtrip0, file.path(input_data_cd, paste0("directed_trips_calibration_", s,".feather")))
for(i in 1:3) {
#catch<-read_dta(file.path(iterative_input_data_cd, paste0("calib_catch_draws_",s, "_", i,".dta")))
#write_feather(catch, file.path(iterative_input_data_cd, paste0("calib_catch_draws_",s, "_", i,".feather")))
# make fake projection draws
write_feather(catch, file.path(iterative_input_data_cd, paste0("projected_catch_draws_",s, "_", i,".feather")))
}
}
#Prior to running the model, transfer the catch_draw files from .csv to .feather to reduce computing time
statez <- c("MA", "RI", "CT", "NY", "NJ", "DE", "MD", "VA", "NC")
for(s in statez) {
dtrip0<-read.csv(file.path(input_data_cd, paste0("directed_trips_calibration_", s,".csv")))
write_feather(dtrip0, file.path(input_data_cd, paste0("directed_trips_calibration_", s,".feather")))
for(i in 1:3) {
catch<-read_dta(file.path(iterative_input_data_cd, paste0("calib_catch_draws_",s, "_", i,".dta")))
#write_feather(catch, file.path(iterative_input_data_cd, paste0("calib_catch_draws_",s, "_", i,".feather")))
# make fake projection draws
write_feather(catch, file.path(iterative_input_data_cd, paste0("projected_catch_draws_",s, "_", i,".feather")))
}
}
View(calibrated_combined)
options(scipen = 999)
packages <- c("tidyr",  "magrittr", "tidyverse", "reshape2", "splitstackshape","doBy","WriteXLS","Rcpp",
"ggplot2","dplyr","rlist","fitdistrplus","MASS","psych","rgl","copula","VineCopula","scales",
"univariateML","logspline","readr","data.table","conflicted", "readxl", "writexl", "fs",
"purrr", "readr", "here","plyr" , "furrr", "profvis", "future", "magrittr", "feather", "RStata", "haven")
# Install only those not already installed
installed <- packages %in% rownames(installed.packages())
if (any(!installed)) {
install.packages(packages[!installed])
}
lapply(packages, library, character.only = TRUE)
conflicts_prefer(dplyr::mutate)
conflicts_prefer(here::here)
#There are four folders needed::
#input data - contains all the MRIP, biological data, angler characteristics data, as well as some data generated in the simulation
#code - contains all the model code
#output_data - this folder is empty to begin with. It stores final simulation output
#iterative_data -this folder is empty to begin with. It compiles data generated in the simulation
#Need to ensure that the globals below are set up in both this file and the stata model_wrapper.do file.
#Set up R globals for input/output data and code scripts
# input_data_cd=here("lou_files","cod_haddock","input_data")
# code_cd=here("lou_files","cod_haddock","code")
# output_data_cd=here("lou_files","cod_haddock","output_data")
# iterative_input_data_cd=here(input_data_cd, "iterative_data")
input_data_cd=here("Data")
test_data_cd=here("Data", "Test_data")
code_cd=here("Code", "sim")
#output_data_cd=here("lou_files","cod_haddock","output_data")
iterative_input_data_cd="C:/Users/andrew.carr-harris/Desktop/flukeRDM_iterative_data"
input_data_cd="C:/Users/andrew.carr-harris/Desktop/MRIP_data_2025"
###################################################
###############Pre-sim Stata code##################
###################################################
#Stata code extracts and prepares the data needed for the simulation
#Connect Rstudio to Stata
#options("RStata.StataPath" = "\"C:\\Program Files\\Stata17\\StataMP-64\"")
#options("RStata.StataVersion" = 17)
#Set number of original draws. We use 150 for the final run. Choose a lot fewer for test runs
n_simulations<-100
n_draws<-50 #Number of simulated trips per day
#Lou's repos
iterative_input_data_cd="C:/Users/andrew.carr-harris/Desktop/flukeRDM_iterative_data"
input_data_cd="C:/Users/andrew.carr-harris/Desktop/MRIP_data_2025"
#check
############# To Run Individual
# Variables to change
dr<-1
st="MA"
library(magrittr)
############# To Run in Loop
#for (st in c("MA", "RI")){
#  for (dr in 1:2){
# import necessary data
directed_trips<-feather::read_feather(file.path(input_data_cd, paste0("directed_trips_calibration_", st, ".feather"))) %>%
tibble::tibble() %>%
dplyr::filter(draw == dr) %>%
dplyr::select(mode, date, bsb_bag, bsb_min, fluke_bag,fluke_min, scup_bag, scup_min,
bsb_bag_y2, bsb_min_y2, fluke_bag_y2,fluke_min_y2, scup_bag_y2, scup_min_y2)
catch_data <- feather::read_feather(file.path(iterative_input_data_cd, paste0("projected_catch_draws_",st, "_", dr,".feather"))) %>%
dplyr::left_join(directed_trips, by=c("mode", "date"))
catch_data<-catch_data %>%
dplyr::select(-cost, -total_trips_12, -age, -bsb_keep_sim, -bsb_rel_sim, -day_i, -my_dom_id_string,
-scup_keep_sim, -scup_rel_sim, -sf_keep_sim, -sf_rel_sim, -wave)
l_w_conversion <- readr::read_csv(file.path("C:/Users/andrew.carr-harris/Desktop/Git/flukeRDM/Data", "L_W_Conversion.csv"), show_col_types = FALSE)  %>%
dplyr::filter(state==st)
sf_size_data <- read_csv(file.path(input_data_cd, "baseline_catch_at_length.csv"), show_col_types = FALSE)  %>%
dplyr::filter(state == st, species=="sf", draw==dr) %>%
dplyr::filter(!is.na(fitted_prob)) %>%
dplyr::select(state, fitted_prob, length)
bsb_size_data <- read_csv(file.path(input_data_cd, "baseline_catch_at_length.csv"), show_col_types = FALSE)  %>%
dplyr::filter(state == st, species=="bsb" , draw==dr) %>%
dplyr::filter(!is.na(fitted_prob)) %>%
dplyr::select(state, fitted_prob, length)
scup_size_data <- read_csv(file.path(input_data_cd, "baseline_catch_at_length.csv"), show_col_types = FALSE)  %>%
dplyr::filter(state == st, species=="scup", draw==dr) %>%
dplyr::filter(!is.na(fitted_prob)) %>%
dplyr::select(state,  fitted_prob, length)
# base-year trip outcomes
base_outcomes0 <- list()
n_choice_occasions0 <- list()
mode_draw <- c("sh", "pr", "fh")
for (md in mode_draw) {
# pull trip outcomes from the calibration year
base_outcomes0[[md]]<-feather::read_feather(file.path(iterative_input_data_cd, paste0("base_outcomes_", st, "_", md, "_", dr, ".feather"))) %>%
data.table::as.data.table()
base_outcomes0[[md]]<-base_outcomes0[[md]] %>%
dplyr::select(-domain2) %>%
dplyr::mutate(date_parsed=lubridate::dmy(date)) %>%
dplyr::select(-date)
# pull in data on the number of choice occasions per mode-day
n_choice_occasions0[[md]]<-feather::read_feather(file.path(iterative_input_data_cd, paste0("n_choice_occasions_MA_", md, "_", dr, ".feather")))
n_choice_occasions0[[md]]<-n_choice_occasions0[[md]] %>%
dplyr::mutate(date_parsed=lubridate::dmy(date)) %>%
dplyr::select(-date)
}
base_outcomes <- bind_rows(base_outcomes0)
n_choice_occasions <- bind_rows(n_choice_occasions0) %>%
dplyr::arrange(date_parsed, mode)
rm(base_outcomes0, n_choice_occasions0)
base_outcomes<-base_outcomes %>%
dplyr::arrange(date_parsed, mode, tripid, catch_draw)
# Pull in calibration comparison information about trip-level harvest/discard re-allocations
calib_comparison<-feather::readRDS(file.path(iterative_input_data_cd, "calibrated_model_stats.rds")) %>%
dplyr::filter(state==st & draw==dr )
calib_comparison<-readRDS(file.path(iterative_input_data_cd, "calibrated_model_stats.rds")) %>%
dplyr::filter(state==st & draw==dr )
View(calib_comparison)
View(directed_trips)
floor_subl_sf_harv<-min(directed_trips$fluke_min)-3*2.54
floor_subl_bsb_harv<-min(directed_trips$bsb_min)-3*2.54
floor_subl_scup_harv<-min(directed_trips$scup_min)-3*2.54
sf_zero_catch0 <- dplyr::filter(catch_data, sf_cat == 0)
bsb_zero_catch0 <- dplyr::filter(catch_data, bsb_cat == 0)
scup_zero_catch0 <- dplyr::filter(catch_data, scup_cat == 0)
# Check if there is zero catch for any species and if so, pipe code around keep/release determination
sf_catch_check<-base::sum(catch_data$sf_cat)
bsb_catch_check<-base::sum(catch_data$bsb_cat)
scup_catch_check<-base::sum(catch_data$scup_cat)
sf_catch_data <- dplyr::filter(catch_data, sf_cat > 0)
row_inds <- seq_len(nrow(sf_catch_data))
sf_catch_data<-sf_catch_data %>%
dplyr::slice(rep(row_inds, sf_cat))   %>%
dplyr::mutate(fishid=dplyr::row_number())
# generate lengths for each fish
catch_size_data <- sf_catch_data %>%
dplyr::mutate(fitted_length = sample(sf_size_data$length,
nrow(.),
prob = sf_size_data$fitted_prob,
replace = TRUE))
# Impose regulations, calculate keep and release per trip
catch_size_data <- catch_size_data %>%
dplyr::mutate(posskeep = ifelse(fitted_length>=fluke_min_y2 ,1,0)) %>%
dplyr::group_by(tripid, date, mode, catch_draw) %>%
dplyr::mutate(csum_keep = cumsum(posskeep)) %>%
dplyr::ungroup() %>%
dplyr::mutate(
keep_adj = dplyr::case_when(
fluke_bag_y2 > 0 ~ ifelse(csum_keep<=fluke_bag_y2 & posskeep==1,1,0),
TRUE ~ 0))
catch_size_data <- catch_size_data %>%
dplyr::mutate_if(is.numeric, tidyr::replace_na, replace = 0)
catch_size_data <- catch_size_data %>%
dplyr::mutate(keep = keep_adj,
release = ifelse(keep==0,1,0)) %>%
dplyr::select(fishid, fitted_length, tripid, keep, release, date, catch_draw, mode)
catch_size_data0<- catch_size_data %>%
dplyr::select(fishid, fitted_length, tripid, keep, release, date, catch_draw, mode) %>%
dplyr::mutate(subl_harv_indicator=dplyr::case_when(release==1 & fitted_length>=floor_subl_sf_harv~1,TRUE~0))
View(catch_size_data)
keep_release_list_sf<- list()
mode_list_sf <- list()
mode_draw <- c("sh", "pr", "fh")
md<-"pr"
catch_size_data<- catch_size_data0 %>%
dplyr::filter(mode==md)
sum_sf_rel<-sum(catch_size_data$release)
sum_sf_keep<-sum(catch_size_data$keep)
calib_comparison_md<-calib_comparison %>%
dplyr::filter(species=="sf" & mode==md)
rel_to_keep_md<- mean(calib_comparison_md$rel_to_keep)
p_rel_to_keep_md<- mean(calib_comparison_md$p_rel_to_keep)
View(calib_comparison_md)
rel_to_keep_md<- mean(calib_comparison_md$rel_to_keep_sf)
p_rel_to_keep_md<- mean(calib_comparison_md$p_rel_to_keep_sf)
keep_to_rel_md<- mean(calib_comparison_md$keep_to_rel_sf)
keep_to_rel_md<- mean(calib_comparison_md$keep_to_rel_sf)
p_keep_to_rel_md<- mean(calib_comparison_md$p_keep_to_rel_sf)
rel_to_keep_md
sum_sf_rel
View(catch_size_data)
View(base_outcomes)
View(catch_data)
View(base_outcomes)
base_outcomes_md<-base_outcomes %>%
dplyr::filter(mode==md)
1160/12
104*12
120*12
